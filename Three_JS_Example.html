<!DOCTYPE html>
<html lang="en">
	<head>
		<title>ballen</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<header>



		<div id="clickToPlay"><p>Click to play</p></div>

		<div id="sound">

			<img src ="shared/img/sound_on.png" width="50px" id="soundImage">

		</div>


		<div id="player"><p id="playerText">Player 1</p></div>

		<div id="hasFull"><p id="hasFullText"></p></div>

		<div id="powerMeter"></div>


		<div id="clickField"></div>

	</header>
	<body>

		<!--<div id="blocker">

			<div id="instructions">
				<span style="font-size:40px">Press any key to continue</span>
				<br />
				(SPACE = Shoot, SCROLL = Zoom, DRAG = Rotate Camera)
			</div>

		</div>-->



		<link href="shared/css/main.css" rel="stylesheet" type="text/css">
		<script src="shared/js/three.js"></script>
		<script src="shared/js/OrbitControls.js"></script>
		<script src="scripts/jquery-3.2.1.min.js"></script>

		<!--<script src="js/SpotLight.js"></script>
		<script src="js/FirstPersonControls.js"></script>-->
		<script>

			javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//rawgit.com/mrdoob/stats.js/master/build/stats.min.js';document.head.appendChild(script);})()


			var mouseDown = 0;

            var beurtBehouden = false;
            var heeftGeschoten = false;

			var powerMeter = document.getElementById("powerMeter");
			var meterUp = true;
			var meterWidth = 0;

			var keuAnimation = 0;
			var fullBalls = 0;
			var halfBalls = 0;

			var CameraFocusObject = new THREE.Vector3(0,0,0);

			var barSounds, balSound, fallSound, queSound, wallSound, scoredSound, soundDisabled, sounds, volumes;

			var playerOne, scored, firstBall, playerOneHasFull;

				playerOne = true;
				scored = false;
				firstBall = true;
				playerOneHasFull = false;

			var mouse, controls, camera, renderer, scene, camPos, raycaster, keu;


				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera(3700, window.innerWidth / window.innerHeight, 5, 10000);

				camPos = camera.position;
				camPos.set(x = 0,y = 500,z = 1250);

				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x000000);
				renderer.shadowMapEnabled = true;
				renderer.shadowMap.type = THREE.BasicShadowMap;

				controls = new THREE.OrbitControls(camera, renderer.domElement);
				controls.enableRotate = false;



            	window.addEventListener( 'resize', onWindowResize, false );


				var stick;

				mouse = new THREE.Vector2();

			    raycaster = new THREE.Raycaster();
			class PoolBal{

				constructor(baldirection, ball)
				{

					this.balDirection = baldirection;
					this.ball = ball;
					this.collision = 0;
					this.fall = 0;

				}
			}

			function init()
			{
				addSound();
				render();
				createRoom();
				createPoolTable();
				addBalls();

				document.body.appendChild(renderer.domElement);
				document.documentElement.style.overflow = 'hidden';  // firefox, chrome

				THREE.ImageUtils.crossOrigin = 'anonymous';

			}

			function addSound(){
				soundDisabled = false;
				barSounds = new Audio('sound/bar.mp3');
					barSounds.loop = true;
					barSounds.play();
					barSounds.volume = 0.1;
				balSound = new Audio('sound/bal.mp3');
					balSound.volume = 1;
				fallSound = new Audio('sound/fall.mp3');
				queSound = new Audio('sound/hit.mp3');
				wallSound = new Audio('sound/wall.mp3');
				scoredSound = new Audio('sound/claps.mp3');


				sounds = [barSounds,  balSound, fallSound, queSound, wallSound, scoredSound];
				volumes = [0.1, 1, 1 ,1, 0.5 ,1];
				
				
			}

			function createRoom() {

				var floor, lightStandard, wall, betonMaterial, wallMaterial, lightAmbient1, lightAmbient2, betonTexture;


				betonTexture = THREE.ImageUtils.loadTexture('shared/img/beton.jpg');
					betonTexture.minFilter = THREE.LinearFilter;
				betonMaterial = new THREE.MeshPhongMaterial({map: betonTexture});
				wallMaterial = new THREE.MeshBasicMaterial({color: 0xf5f0ff});

				floor = new THREE.Mesh(new THREE.PlaneBufferGeometry(10000, 10000, 50, 50), betonMaterial);
				floor.position.y = -750;
				floor.rotation.x = -Math.PI / 2;
				floor.receiveShadow = true;
				floor.castShadow = true;

				wall = new THREE.Mesh(new THREE.PlaneBufferGeometry(19000, 10000, 50, 50), wallMaterial);
				wall.position.z = -10000;


				lightStandard = new THREE.PointLight(0xffffff, 3, 4000);
				lightStandard.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({color: 0xf0f0f0})));
				lightStandard.position.set(100, 500, 0);
				scene.add(floor);
				scene.add(lightStandard);

			}

			function createPoolTable() {

				var poolTafel, tafelKleedMaterial, tafelKleed, randGeometry_X, randGeometry_Y,
						tafelPootGeometry, randMaterial, rand4, rand1, rand2, rand3, circleGeometry,
						blackMaterial, circle1, circle2, circle3, circle4, circle5, circle6,
						keuGeometry, keuMaterial, woodMaterial, tafelPoten, keuPositie;

				woodMaterial = THREE.ImageUtils.loadTexture('shared/img/wood.jpg');
				randMaterial = new THREE.MeshPhongMaterial({map: woodMaterial});
				tafelKleedMaterial = new THREE.MeshPhongMaterial({color: 0x228B22});
				keuMaterial = new THREE.MeshPhongMaterial({color: 0xC9A281});
				blackMaterial = new THREE.MeshBasicMaterial({color: 0x000000});

				randGeometry_X = new THREE.BoxGeometry(150, 250, 2000);
				randGeometry_Y = new THREE.BoxGeometry(1250, 250, 50);
				tafelPootGeometry = new THREE.BoxGeometry(100, 2000, 100);
				keuGeometry = new THREE.BoxGeometry(10, 10, 300);
				circleGeometry = new THREE.CircleBufferGeometry(75, 1600);

				poolTafel = new THREE.Group();

				tafelKleed = new THREE.Mesh(new THREE.BoxGeometry(1000, 10, 2000), tafelKleedMaterial);
				tafelKleed.position.y = -50;
				tafelKleed.receiveShadow = true;
				tafelKleed.castShadow = true;

				rand1 = new THREE.Mesh(randGeometry_X, randMaterial);
				rand2 = new THREE.Mesh(randGeometry_X, randMaterial);
				rand3 = new THREE.Mesh(randGeometry_Y, randMaterial);
				rand4 = new THREE.Mesh(randGeometry_Y, randMaterial);

				rand1.position.set(-550, -100, 0);
				rand2.position.set(550, -100, 0);
				rand3.position.set(0, -100, -1000);
				rand4.position.set(0, -100, 1000);

				tafelPoten = new THREE.Group();

				tafelPoot1 = new THREE.Mesh(tafelPootGeometry, randMaterial);
				tafelPoot2 = new THREE.Mesh(tafelPootGeometry, randMaterial);
				tafelPoot3 = new THREE.Mesh(tafelPootGeometry, randMaterial);
				tafelPoot4 = new THREE.Mesh(tafelPootGeometry, randMaterial);

				tafelPoten.add(tafelPoot1, tafelPoot2, tafelPoot3, tafelPoot4);

				tafelPoot1.position.set(-550, -1000, 1000);
				tafelPoot2.position.set(550, -1000, 1000);
				tafelPoot3.position.set(550, -1000, -1000);
				tafelPoot4.position.set(-550, -1000, -1000);

				circle1 = new THREE.Mesh(circleGeometry, blackMaterial);
				circle1.rotation.x = -Math.PI / 2;
				circle1.position.y = -50;

				circle1.position.z = -950;
				circle1.position.x = -450;
				poolTafel.add(circle1);

				circle2 = circle1.clone();
				circle2.position.x = 450;
				poolTafel.add(circle2);

				circle3 = circle1.clone();
				circle3.position.z = 950;
				poolTafel.add(circle3);

				circle4 = circle3.clone();
				circle4.position.x = 450;
				poolTafel.add(circle4);

				circle5 = circle3.clone();
				circle5.position.z = 0;
				circle5.position.x = -475;
				poolTafel.add(circle5);

				circle6 = circle5.clone();
				circle6.position.x = 475;
				poolTafel.add(circle6);

				keu = new THREE.Mesh(keuGeometry, keuMaterial);
				keu.rotateX(-5);
				keu.position.y = 150;

				keuPositie = new THREE.Vector3(0,0,0);
				keuPositie.addVectors(witteBal.position, camPos);

				keuPositie = keuPositie.multiplyScalar(25);

				keu.position.x = keuPositie.x;
				keu.position.z = keuPositie.z;

				keu.rotation.z = -camera.rotation.z;

				keu.visible = false;

				poolTafel.add(rand2);
				poolTafel.add(rand3);
				poolTafel.add(rand4);
				poolTafel.add(rand1);
				poolTafel.add(tafelKleed);
				poolTafel.add(tafelPoten);

				poolTafel.castShadow = true;
				poolTafel.receiveShadow = false;

				scene.add(keu);
				scene.add(poolTafel);
			}


			function addBalls(){

			}


			var poolBallen, alleBallen, ballenLiggenStil, speed, clock, rotationPerFrame, rotationVector, sphere;

			sphere = new THREE.SphereGeometry(25, 800, 400);
			poolBallen = [];
			alleBallen = [];


			ballenLiggenStil = true;

			speed = new THREE.Vector3();

			clock = new THREE.Clock();

			rotationPerFrame = 0.05;
			rotationVector = new THREE.Vector3(rotationPerFrame,rotationPerFrame,rotationPerFrame);

















			// ############################################ pooltafel ##################################################



			// ############################################# balls #####################################################
			var ballen = new THREE.Group();
			var witteBal = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0xFFFFFF}));
			CameraFocusObject = witteBal.position;

			for (var i = 1; i < 16; i++) {
				/*
				 if (i % 2 == 0) {
				 var Poolball = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0xff0040}));
				 }
				 else {
				 if (i == 11) {
				 var Poolball = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0x00000}));
				 }
				 else {
				 var Poolball = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0x0040ff}));
				 }
				 }
				 */

				var ballTexture = new THREE.TextureLoader().load('balls/' + i + "ball.png");
				var Poolball = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({map: ballTexture}));

				ballen.add(Poolball);
			}


			//ballen array
			for (var i = 0 ; i < ballen.children.length; i ++){

				ballen.children[i].name = "bal" + i;
				var bal = new PoolBal(new THREE.Vector3(0,0,0), ballen.children[i]);
				bal.name = "poolbal" + i;
				poolBallen.push(bal);
				alleBallen.push(ballen.children[i]);
			}

			witteBal.name = "bal" + 15;
			alleBallen.push(witteBal);




			var wittePoolBal = new PoolBal(new THREE.Vector3(0, 0, 0), witteBal);
			wittePoolBal.name = "poolbal" + 15;
			poolBallen.push(wittePoolBal);


			function returnBalDir(ball){

				for (var i = 0; i < poolBallen.length; i++){

					if (poolBallen[i].name == ball)
					{
						return poolBallen[i];
					}
				}
			}



			// ballen.position.z = 1;
			//ballen.position.x = -5;
			function resetBalls() {


				for (var i = 0 ; i < poolBallen.length; i ++){
					poolBallen[i].ball.visible = true;
					poolBallen[i].balDirection = new THREE.Vector3(0,0,0);
					poolBallen[i].ball.position.y = 0;
					poolBallen[i].collision = 0;
				}


				scene.add(ballen);
				scene.add(witteBal);




				witteBal.position.z = 500;
				witteBal.position.x = 0;

				for (var i = 0; i < ballen.children.length; i++) {
					ballen.children[i].position.z = -250;
					ballen.children[i].position.x = (i * 60) - 100;
					if (i >= 5) {
						ballen.children[i].position.x = (i * 60) - 360;
						ballen.children[i].position.z = -190;
					}
					if (i >= 9) {
						ballen.children[i].position.x = (i * 60) - 590;
						ballen.children[i].position.z = -130;
					}
					if (i >= 12) {
						ballen.children[i].position.x = (i * 60) - 750;
						ballen.children[i].position.z = -70;
					}
					if (i >= 14) {
						ballen.children[i].position.x = (i * 60) - 820;
						ballen.children[i].position.z = -10;
					}
				}


			}

			resetBalls();


			var lineMaterial = new THREE.LineDashedMaterial({ color: 0x000000 });
			var lineGeometry = new THREE.Geometry();
			var line = new THREE.Line(lineGeometry, lineMaterial);
			lineGeometry.vertices.push(witteBal.position);
			var direction = witteBal.position.clone().sub( camera.position ).normalize();
			direction.y = 0;
			lineGeometry.vertices.push(direction.clone().multiplyScalar(500));
			scene.add(line);



			// ************************************* MANAGE BOUNCE ***************************************

			function BounceMyBalls(ball, ball2)
			{



				var warmteEnergieRendement = 0.95;

				var mass = 1;

				var dx = ball.ball.position.x - ball2.ball.position.x;
				var dy = ball.ball.position.z - ball2.ball.position.z;

				var collision_angle = Math.atan2(dy, dx);
				var magnitude_1 = Math.sqrt(ball.balDirection.x * ball.balDirection.x + ball.balDirection.z * ball.balDirection.z  )
				var magnitude_2 = Math.sqrt(ball2.balDirection.x * ball2.balDirection.x + ball2.balDirection.z * ball2.balDirection.z  )

				var direction_1 = Math.atan2( ball.balDirection.z, ball.balDirection.x);
				var direction_2 = Math.atan2( ball2.balDirection.z, ball2.balDirection.x);

				var new_xspeed_1 = magnitude_1 * Math.cos(direction_1 - collision_angle);
				var new_yspeed_1 = magnitude_1 * Math.sin(direction_1 - collision_angle);
				var new_xspeed_2 = magnitude_2 * Math.cos(direction_2 - collision_angle);
				var new_yspeed_2 = magnitude_2 * Math.sin(direction_2 - collision_angle);

				var final_xspeed_1 = ((mass-mass)*new_xspeed_1+(mass+mass)*new_xspeed_2)/(mass+mass);
				var final_xspeed_2 = ((mass+mass)*new_xspeed_1+(mass-mass)*new_xspeed_2)/(mass+mass);
				var final_yspeed_1 = new_yspeed_1;
				var final_yspeed_2 = new_yspeed_2;

				ball.balDirection.x = warmteEnergieRendement * (Math.cos(collision_angle)*final_xspeed_1+Math.cos(collision_angle+Math.PI/2)*final_yspeed_1);
				ball.balDirection.z = warmteEnergieRendement  * (Math.sin(collision_angle)*final_xspeed_1+Math.sin(collision_angle+Math.PI/2)*final_yspeed_1);
				ball2.balDirection.x = warmteEnergieRendement * (Math.cos(collision_angle)*final_xspeed_2+Math.cos(collision_angle+Math.PI/2)*final_yspeed_2);
				ball2.balDirection.z = warmteEnergieRendement * ( Math.sin(collision_angle)*final_xspeed_2+Math.sin(collision_angle+Math.PI/2)*final_yspeed_2);


				balSound.play();




			}

			function getPointInBetweenByLen(pointA, pointB, length) {

				var dir = pointB.clone().sub(pointA).normalize().multiplyScalar(length);
				return pointA.clone().add(dir);

			}

			// ############################################# render ###################################################
			function render() {


				if (ballenLiggenStil){
					lineGeometry.vertices[0] = (witteBal.position);
					var direction = witteBal.position.clone().sub(camera.position).normalize();
					direction.y = 0;
					direction.x = direction.clone().multiplyScalar(2000).x;
					direction.z = direction.clone().multiplyScalar(2000).z;

					var linePos = witteBal.position.clone().add(direction)

					lineGeometry.vertices[1] = (linePos);
					line.geometry.verticesNeedUpdate = true;
				}
				else{
					lineGeometry.vertices[0] = new THREE.Vector3(0,0,0);
					lineGeometry.vertices[1] = new THREE.Vector3(0,0,0);
					line.geometry.verticesNeedUpdate = true;
				}


                var clockDelta = clock.getDelta() * 20;


                if(mouseDown && ballenLiggenStil){

					if (meterWidth >= 100){meterUp = false}

					if (meterWidth <= 0){meterUp = true;}

					if (meterUp) {meterWidth+= clockDelta * 10;}
					else {meterWidth -= clockDelta * 10;}

					powerMeter.style.width = meterWidth + "px";
				}

				if (keuAnimation > 0){
					keuAnimation += clockDelta;

					var keupos = getPointInBetweenByLen(witteBal.position, keu.position, 500 - keuAnimation + 325);

					keu.position.y = 150;
					keu.position.x = keupos.x;
					keu.position.z = keupos.z;

					if (keuAnimation >= 10){
						keuAnimation = 0;
						rollWitteBal();
					}
				}


				var drag = 0.996;

				poolBallen[15].balDirection.y = 0;
				witteBal.position.add(speed.copy(poolBallen[15].balDirection.multiplyScalar(drag)).multiplyScalar(clockDelta));
				//poolBallen[15].ball.position.add(poolBallen[15].balDirection);

				for (var i = 0; i < ballen.children.length; i++) {
					poolBallen[i].balDirection.y = 0;

					var newDirection = speed.copy(poolBallen[i].balDirection.multiplyScalar(drag)).multiplyScalar(clockDelta);

					//poolBallen[i].ball.position.add(poolBallen[i].balDirection);
					poolBallen[i].ball.position.add(newDirection);

					poolBallen[i].ball.rotateX(newDirection.z / 50 * Math.PI) ;
					poolBallen[i].ball.rotateZ(-newDirection.x / 50 * Math.PI) ;
					//poolBallen[i].ball.rotateY(-(poolBallen[i].balDirection.y / (0.5 * Math.PI)) * clockDelta) ;
				}


				renderer.setSize(window.innerWidth, window.innerHeight);


				camera.lookAt(CameraFocusObject);

				requestAnimationFrame(render);
				raycaster.setFromCamera(mouse, camera);
				renderer.render(scene, camera);


				for (var x=0; x < poolBallen.length; x++) {
					for (var y = x + 1; y < poolBallen.length; y++) {
						if (poolBallen[i].collision == 2){continue;}

						var distance_x = Math.abs(poolBallen[x].ball.position.x - poolBallen[y].ball.position.x);
						var distance_y = Math.abs(poolBallen[x].ball.position.z - poolBallen[y].ball.position.z);
						var distance = Math.sqrt(distance_x * distance_x + distance_y * distance_y);

						if (distance <= 50 && (poolBallen[x].collision == 0 || poolBallen[y].collision == 0)) {
							poolBallen[x].collision = 1;
							poolBallen[y].collision = 1;

							if (poolBallen[x].ball.position.y < 0 || poolBallen[y].ball.position.y < 0){
								continue;
							}

							var remainDistance = 50 - distance;
							if (remainDistance > 0)
							{
								var direction = poolBallen[x].ball.position.clone().sub( poolBallen[y].ball.position ).normalize();
								poolBallen[x].ball.position.add(direction.clone().multiplyScalar(remainDistance));
							}

							BounceMyBalls(poolBallen[x], poolBallen[y]);
						}
						else if (distance > 50) {
							poolBallen[x].collision = 0;
							poolBallen[y].collision = 0;
						}
					}
				}


				var stilleBallen = true;

				for (var i = 0; i < poolBallen.length; i ++) {


					var dir = poolBallen[i].balDirection;
					if (!(dir.x <= 0.50 && dir.z <= 0.50  && dir.x > -0.50  && dir.z > -0.50 ) && poolBallen[i].ball.position.y == 0){
						stilleBallen = false;
					}
					if (i == 15 && stilleBallen == true && ballenLiggenStil == false && heeftGeschoten ){
						ballenLiggenStil = true;
                        heeftGeschoten = false;

						meterWidth = 0;

                        document.getElementById("clickToPlay").style.display = "block";

                        if (!beurtBehouden || !scored){
                            playerOne = !playerOne;
                        }
                        else {
							scoredSound.play();
						}

						if (playerOne){
							document.getElementById("playerText").innerHTML  = "Player 1";
							document.getElementById("player").style.color  = "green";
						}
						else{
							document.getElementById("playerText").innerHTML  = "Player 2";
							document.getElementById("player").style.color  = "red";
						}

						if (poolBallen[15].ball.position.y < 0) {
							resetWitteBal();
						}

					}

					var pos = poolBallen[i].ball.position;

					var fallen = poolBallen[i].collision;

					//up
					if (pos.z > 950 && fallen == 0) {
						pos.z = 950;
						poolBallen[i].balDirection.z *= -1;

						wallSound.play();
					}

					//down
					if (pos.z < -950 && fallen == 0) {
						pos.z = -950;
						poolBallen[i].balDirection.z *= -1;

						wallSound.play();
					}

					if (pos.x < -450 && fallen == 0) {
						pos.x = -450;
						poolBallen[i].balDirection.x *= -1;

						wallSound.play();
					}

					if (pos.x > 450 && fallen == 0) {
						pos.x = 450;
						poolBallen[i].balDirection.x *= -1;

						wallSound.play();
					}



					if ((pos.z > 900 || pos.z < -900) && (pos.x > 400 || pos.x < -400)  && pos.y == 0){
						fallPoolball(poolBallen[i]);
					}


					//vallen van middelste gaten
					if (pos.x < -400 || pos.x > 412.5) {
						if ((pos.z < 75 && poolBallen[i].ball.position.z > -75 ) && pos.y == 0) {
							fallPoolball(poolBallen[i]);
						}
					}


					if (poolBallen[i].fall > 0) {
						pos.y -= 5;
						if (pos.y <= -50) {
							poolBallen[i].fall = 0;
							poolBallen[i].ball.visible = false;

						}
					}
				}
			}



			function  fallPoolball(ball) {


			    var nr = poolBallen.indexOf(ball);

				fallSound.play();

				if (ball.balDirection.x > 25) { ball.balDirection.x = 25;}
				if (ball.balDirection.x < -25) { ball.balDirection.x = -25;}
				if (ball.balDirection.y > 25) { ball.balDirection.y = 25;}
				if (ball.balDirection.y < -25) { ball.balDirection.y = -25;}


				ball.ball.position.y -= 5;
				ball.collision = 2;
				ball.fall = 1;

				if (nr == 15){
				    //witte Bal geput
                    beurtBehouden = false;
					CameraFocusObject = new THREE.Vector3(0,150,400);
				}
				else if (nr == 7){
				    //zwarte bal
                    beurtBehouden = false;
                    stopGame();
				}
				else if (firstBall){
				    firstBall = false;
				    if (nr <= 6){
                   	 	playerOneHasFull = playerOne;
					}
					else{
				        playerOneHasFull = !playerOne;
					}
					if (playerOneHasFull){
				        document.getElementById("hasFullText").innerHTML = "Player 1 has full";
					}
					else{
                        document.getElementById("hasFullText").innerHTML = "Player 2 has full";
                        document.getElementById("hasFullText").style.color = "red";
					}
					scored = true;

				}
				else if (playerOne && nr <= 6 && playerOneHasFull){
				    fullBalls++;
                    scored = true;
				}
                else if (!playerOne && nr <= 6 && !playerOneHasFull){
                    fullBalls++;
                    scored = true;
                }
                else if (playerOne && nr >= 8 && !playerOneHasFull){
                    halfBalls++;
                    scored = true;
                }
                else if (!playerOne && nr >= 6 && playerOneHasFull){
                    halfBalls++;
                    scored = true;
                }



			}

			function resetWitteBal() {
				poolBallen[15].fall = 0;
				poolBallen[15].ball.position.x = 0;
				poolBallen[15].ball.position.z = 10;
				poolBallen[15].ball.visible = true;
				poolBallen[15].balDirection = new THREE.Vector3(0,0,0);
				poolBallen[15].ball.position.y = 0;
				poolBallen[15].collision = 0;
				CameraFocusObject = witteBal.position;
			}

			function  stopGame() {
				if (playerOne){
					if ((playerOneHasFull && fullBalls == 7) || (!playerOneHasFull && halfBalls == 7)){
					    document.getElementById("playerText").innerHTML = "Player one has won";
					}
					else
					{
                        document.getElementById("playerText").innerHTML = "Player two has won";
					}
				}
				else
				{
                    if ((!playerOneHasFull && fullBalls == 7) || (playerOneHasFull && halfBalls == 7)){
                        document.getElementById("playerText").innerHTML = "Player two has won";
                    }
                    else
					{
                        document.getElementById("playerText").innerHTML = "Player one has won";
					}
				}
            }


			// ########################################## mouse events #################################################


			var soundImage = document.getElementById("soundImage");

			document.addEventListener( 'click', onClick);
			soundImage.addEventListener('click', onSoundClick);


			function onSoundClick(){
				soundDisabled = !soundDisabled;
				console.log(soundDisabled);

				if(!soundDisabled){
					soundImage.src = "shared/img/sound_on.png";
					for (var i = 0; i < sounds.length; i++){
						sounds[i].volume = volumes[i];
					}
				}
				else{
					soundImage.src = "shared/img/sound_off.png";
					for (var i = 0; i < sounds.length; i++){
						sounds[i].volume = 0;
					}
				}

			}




			$('#clickField').mousedown(function(event) {
				if (event.which == 1) {
					++mouseDown;
					document.getElementById("clickToPlay").style.display = "none";
					if (ballenLiggenStil) {
						keu.visible = true;

						var keupos = getPointInBetweenByLen(witteBal.position, camera.position, 500);

						console.log(keupos);

						keu.position.y = 150;
						keu.position.x = keupos.x;
						keu.position.z = keupos.z;

						console.log(keu.position);

						keu.lookAt(witteBal.position);


					}

				}
			});
			$('#clickField').mouseup(function(event) {
				if (event.which == 1) {
					--mouseDown;
					if(ballenLiggenStil) {
						keuAnimation = meterWidth / 20;
						ballenLiggenStil = false;
					}
				}
			});


			function rollWitteBal(){

                beurtBehouden = true;
				queSound.play();
				ballenLiggenStil = false;
				scored = false;
				var direction = camera.position.clone().sub(poolBallen[15].ball.position).normalize();
				poolBallen[15].balDirection.x = -direction.clone().multiplyScalar((meterWidth / 60) * 50).x;
				poolBallen[15].balDirection.z = -direction.clone().multiplyScalar((meterWidth / 60) * 50).z;
				keu.visible = false;
                heeftGeschoten = true;
			}


			function onClick(){

			}

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

                render();

            }


			init();
		</script>
</body>
</html>