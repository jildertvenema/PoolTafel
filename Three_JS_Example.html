<!DOCTYPE html>
<html lang="en">
	<head>
		<title>ballen</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>

		<div id="blocker">

			<div id="instructions">
				<span style="font-size:40px">Press any key to continue</span>
				<br />
				(SPACE = Shoot, SCROLL = Zoom, DRAG = Rotate Camera)
			</div>

		</div>

		<link href="shared/css/main.css" rel="stylesheet" type="text/css">
		<script src="shared/js/three.js"></script>
		<script src="shared/js/OrbitControls.js"></script>

		
		<!--<script src="js/SpotLight.js"></script>
		<script src="js/FirstPersonControls.js"></script>-->

		<script>
		
			class PoolBal{
				constructor(baldirection, ball)
				{
					this.balDirection = baldirection;
					this.ball = ball;
					this.collision = 0;
					this.fall = 0;
					this.randCollision = 0;
				}				
			}

			var controlsEnabled = false;
			var element = document.body;
			var mouse = new THREE.Vector2();

			function init()
			{

				enablePointerLock();
				render();


			}

			var scene = new THREE.Scene();

			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(x = 0,y = 10,z = 25);


			controls = new THREE.OrbitControls( camera );
			controls.noRotate = true;
			controls.addEventListener( 'change', render );

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0x000000);
			renderer.shadowMapEnabled = true;
			document.body.appendChild(renderer.domElement);

			document.documentElement.style.overflow = 'hidden';  // firefox, chrome

			THREE.ImageUtils.crossOrigin = 'anonymous';
			texture = THREE.ImageUtils.loadTexture('shared/img/beton.jpg');
			wood = THREE.ImageUtils.loadTexture('shared/img/wood.jpg');
			texture.minFilter = THREE.LinearFilter;
			betonMaterial = new THREE.MeshBasicMaterial({
				map: texture
				//color: 0xf0f0f0

			});

			function enablePointerLock()
			{

				var blocker = document.getElementById( 'blocker' );
				var instructions = document.getElementById( 'instructions' );

				var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
				if ( havePointerLock ) {

					var pointerlockchange = function ( event ) {
						if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
							controlsEnabled = true;
							blocker.style.display = 'none';
						} else {
							controlsEnabled = true;
							blocker.style.display = '-webkit-box';
							blocker.style.display = '-moz-box';
							blocker.style.display = '';
							instructions.style.display = '';
						}
					};
					var pointerlockerror = function ( event ) {
						instructions.style.display = '';
					};
					// Hook pointer lock state change events
					document.addEventListener( 'pointerlockchange', pointerlockchange, false );
					document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
					document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
					document.addEventListener( 'pointerlockerror', pointerlockerror, false );
					document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
					document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
				} else {
					instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
				}

			}



		

            // ############################################## init #####################################################



            //var groundTexture = new THREE.TextureLoader().load('img/front.jpg');

            //var floorMat = new THREE.MeshPhongMaterial( { map: groundTexture  } );

            var floor = new THREE.Mesh( new THREE.PlaneBufferGeometry(200,200,1,1), betonMaterial);
            floor.position.y = -15;
            floor.rotation.x = - Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

			var raycaster = new THREE.Raycaster();


			var poolBallen = [];
            var alleBallen = [];


			var speed = new THREE.Vector3();

			var clock = new THREE.Clock();

			var rotationPerFrame = 0.05;
			var rotationVector = new THREE.Vector3(rotationPerFrame,rotationPerFrame,rotationPerFrame);

			//scene.add(new THREE.AmbientLight(0xf0f0f0));
			scene.add( new THREE.AmbientLight(0x111111));

			var sphere = new THREE.SphereGeometry(0.5, 16, 8);

			var light1 = new THREE.DirectionalLight(0xf0f0f0, 1.2, 100, 1);
			light1.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial( { color: 0xf0f0f0 } )));
			light1.position.set(10, 40, 0);
			light1.castShadow = true;
            light1.shadowDarkness = 0.5;

			scene.add(light1);


            wallMaterial = new THREE.MeshBasicMaterial({
                color: 0xf5f0ff

            });
			var wall = new THREE.Mesh( new THREE.PlaneBufferGeometry(370,200,1,1), wallMaterial);
            wall.position.z = -200;
			scene.add(wall);


            // ############################################ pooltafel ##################################################
            var poolTafel = new THREE.Group();



            var tafelKleedMat = new THREE.MeshPhongMaterial({color: 0x228B22});

            var tafelKleed = new THREE.Mesh(new THREE.BoxGeometry(20, 40, 1), tafelKleedMat);
            tafelKleed.position.y = -1;
            tafelKleed.rotation.x = -Math.PI / 2;

            poolTafel.add(tafelKleed);

            var xRandGeo = new THREE.BoxGeometry(1, 1, 40);
            var zRandGeo = new THREE.BoxGeometry(21, 1, 1);
            var tafelPootGeo = new THREE.BoxGeometry(1, 40, 1);

            var randMat = new THREE.MeshPhongMaterial({
                    //color: 0x8B4513
                    map: wood
                }
				);
            var rand0 = new THREE.Mesh(xRandGeo, randMat);
            var rand1 = new THREE.Mesh(xRandGeo, randMat);
            var rand2 = new THREE.Mesh(zRandGeo, randMat);
            var rand3 = new THREE.Mesh(zRandGeo, randMat);

            var zranden = new THREE.Group();
            zranden.add(rand2);
            zranden.add(rand3);

            var xranden = new THREE.Group();
            xranden.add(rand0);
            xranden.add(rand1);

            poolTafel.add(zranden);
            poolTafel.add(xranden);

            rand0.position.set(-10, 0, 0);
            rand1.position.set(10, 0, 0);
            rand2.position.set(0, 0, -20);
            rand3.position.set(0, 0, 20);

            var tafelPoten = new THREE.Group();

            tafelPoot1 = new THREE.Mesh(tafelPootGeo, randMat);
            tafelPoot2 = new THREE.Mesh(tafelPootGeo, randMat);
            tafelPoot3 = new THREE.Mesh(tafelPootGeo, randMat);
            tafelPoot4 = new THREE.Mesh(tafelPootGeo, randMat);

            tafelPoten.add(tafelPoot1, tafelPoot2, tafelPoot3, tafelPoot4);

            tafelPoot1.position.set(-10, -20, 20);
            tafelPoot2.position.set(10, -20, 20);
            tafelPoot3.position.set(10, -20, -20);
            tafelPoot4.position.set(-10, -20, -20);

            poolTafel.add(tafelPoten);

            poolTafel.castShadow = true;
            poolTafel.receiveShadow = false;

            tafelKleedcastShadow = true;



			var circleGeometry = new THREE.CircleBufferGeometry( 1.5, 32 );
			var blackMaterial = new THREE.MeshBasicMaterial( { color: 0x000000 } );
			var circle = new THREE.Mesh( circleGeometry, blackMaterial );
			circle.rotation.x = tafelKleed.rotation.x;
			circle.position.y =  -0.4;


			circle.position.z = -19;
			circle.position.x = -9;
			poolTafel.add( circle );

			var circle2 = circle.clone();
			circle2.position.x = 9;
			poolTafel.add( circle2 );

			var circle3 = circle.clone();
			circle3.position.z = 19;
			poolTafel.add( circle3 );

			var circle4 = circle3.clone();
			circle4.position.x = 9;
			poolTafel.add( circle4 );

			var circle5 = circle3.clone();
			circle5.position.z = 0;
			circle5.position.x = -9.5;
			poolTafel.add( circle5 );

			var circle6 = circle5.clone();
			circle6.position.x = 9.5;
			poolTafel.add( circle6 );


			var stokGeometry = new THREE.CylinderGeometry( 0.2, 0.08, 15, 32 );
			var stokMaterial = new THREE.MeshBasicMaterial( {color: 0xC9A281} );
			var stokje = new THREE.Mesh( stokGeometry, stokMaterial );
			stokje.rotateX(-5);
			stokje.position.y = 3;

			scene.add( stokje );

            scene.add(poolTafel);


            // ############################################# balls #####################################################
            var ballen = new THREE.Group();
            var witteBal = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0xFFFFFF}));

            for (var i = 1; i < 16; i++) {
            	/*
                if (i % 2 == 0) {
                    var Poolball = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0xff0040}));
                }
                else {
                    if (i == 11) {
                        var Poolball = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0x00000}));
                    }
                    else {
                        var Poolball = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0x0040ff}));
                    }
                }
			*/

				var ballTexture = new THREE.TextureLoader().load('balls/' + i + "ball.png");
				var Poolball = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({map: ballTexture}));

                ballen.add(Poolball);
            }


			//ballen array
			for (var i = 0 ; i < ballen.children.length; i ++){

                ballen.children[i].name = "bal" + i;
			var bal = new PoolBal(new THREE.Vector3(0,0,0), ballen.children[i]);
				bal.name = "poolbal" + i;
				poolBallen.push(bal);
				alleBallen.push(ballen.children[i]);
			}

			witteBal.name = "bal" + 15;
            alleBallen.push(witteBal);




            var wittePoolBal = new PoolBal(new THREE.Vector3(0, 0, 0), witteBal);
            wittePoolBal.name = "poolbal" + 15;
			poolBallen.push(wittePoolBal);


			function returnBalDir(ball){

				for (var i = 0; i < poolBallen.length; i++){

					if (poolBallen[i].name == ball)
					{
						return poolBallen[i];
					}
				}
			}



           // ballen.position.z = 1;
            //ballen.position.x = -5;
			function resetBalls() {


                for (var i = 0 ; i < poolBallen.length; i ++){
                    poolBallen[i].ball.visible = true;
                    poolBallen[i].balDirection = new THREE.Vector3(0,0,0);
                    poolBallen[i].ball.position.y = 0;
					poolBallen[i].collision = 0;
                }


                scene.add(ballen);
                scene.add(witteBal);




                witteBal.position.z = 10;
                witteBal.position.x = 0;

                for (var i = 0; i < ballen.children.length; i++) {
                    ballen.children[i].position.z = -5;
                    ballen.children[i].position.x = (i * 1.2) - 2;
                    if (i >= 5) {
                        ballen.children[i].position.x = ((i - 4.5) * 1.2) - 2;
                        ballen.children[i].position.z = -4;
                    }
                    if (i >= 9) {
                        ballen.children[i].position.x = ((i - 8) * 1.2) - 2;
                        ballen.children[i].position.z = -3;
                    }
                    if (i >= 12) {
                        ballen.children[i].position.x = ((i - 10.5) * 1.2) - 2;
                        ballen.children[i].position.z = -2;
                    }
                    if (i >= 14) {
                        ballen.children[i].position.x = ((i - 12) * 1.2) - 2;
                        ballen.children[i].position.z = -1;
                    }
                }


            }
            
            
            function resetWitteBal() {
				witteBal.position.z = 10;
				witteBal.position.x = 0;
				witteBal.position.y = 0;
				poolBallen[15].ball.visible = true;
				poolBallen[15].balDirection = new THREE.Vector3(0,0,0);
				poolBallen[15].ball.position.y = 0;
				poolBallen[15].collision = 0;
			}
            


            resetBalls();




			// ************************************* MANAGE BOUNCE ***************************************

			function BounceMyBalls(ball, ball2)
			{

				var warmteEnergieRendement = 0.95;

			    var mass = 1;

				var dx = ball.ball.position.x - ball2.ball.position.x;
                var dy = ball.ball.position.z - ball2.ball.position.z;

                var collision_angle = Math.atan2(dy, dx);
                var magnitude_1 = Math.sqrt(ball.balDirection.x * ball.balDirection.x + ball.balDirection.z * ball.balDirection.z  )
                var magnitude_2 = Math.sqrt(ball2.balDirection.x * ball2.balDirection.x + ball2.balDirection.z * ball2.balDirection.z  )

				var direction_1 = Math.atan2( ball.balDirection.z, ball.balDirection.x);
                var direction_2 = Math.atan2( ball2.balDirection.z, ball2.balDirection.x);

				var new_xspeed_1 = magnitude_1 * Math.cos(direction_1 - collision_angle);
                var new_yspeed_1 = magnitude_1 * Math.sin(direction_1 - collision_angle);
                var new_xspeed_2 = magnitude_2 * Math.cos(direction_2 - collision_angle);
                var new_yspeed_2 = magnitude_2 * Math.sin(direction_2 - collision_angle);

                var final_xspeed_1 = ((mass-mass)*new_xspeed_1+(mass+mass)*new_xspeed_2)/(mass+mass);
                var final_xspeed_2 = ((mass+mass)*new_xspeed_1+(mass-mass)*new_xspeed_2)/(mass+mass);
                var final_yspeed_1 = new_yspeed_1;
                var final_yspeed_2 = new_yspeed_2;

                ball.balDirection.x = warmteEnergieRendement * (Math.cos(collision_angle)*final_xspeed_1+Math.cos(collision_angle+Math.PI/2)*final_yspeed_1);
                ball.balDirection.z = warmteEnergieRendement  * (Math.sin(collision_angle)*final_xspeed_1+Math.sin(collision_angle+Math.PI/2)*final_yspeed_1);
                ball2.balDirection.x = warmteEnergieRendement * (Math.cos(collision_angle)*final_xspeed_2+Math.cos(collision_angle+Math.PI/2)*final_yspeed_2);
                ball2.balDirection.z = warmteEnergieRendement * ( Math.sin(collision_angle)*final_xspeed_2+Math.sin(collision_angle+Math.PI/2)*final_yspeed_2);


			}



            // ############################################# render ###################################################
			function render() {

				var clockDelta = clock.getDelta() * 20;

                var drag = 0.996;

				poolBallen[15].balDirection.y = 0;
				witteBal.position.add(speed.copy(poolBallen[15].balDirection.multiplyScalar(drag)).multiplyScalar(clockDelta));
				//poolBallen[15].ball.position.add(poolBallen[15].balDirection);

                for (var i = 0; i < ballen.children.length; i++) {
                    poolBallen[i].balDirection.y = 0;
                    //poolBallen[i].ball.position.add(poolBallen[i].balDirection);
                    poolBallen[i].ball.position.add(speed.copy(poolBallen[i].balDirection.multiplyScalar(drag)).multiplyScalar(clockDelta));

					poolBallen[i].ball.rotateX(-poolBallen[i].balDirection.z / 0.5 * clockDelta );
					poolBallen[i].ball.rotateZ(-poolBallen[i].balDirection.x / 0.5 * clockDelta);
                    poolBallen[i].ball.rotateY(-poolBallen[i].balDirection.y / 0.5 * clockDelta);
                }


                renderer.setSize(window.innerWidth, window.innerHeight);


                camera.lookAt(witteBal.position);



				var StokPositie = new THREE.Vector3(0,0,0);
				StokPositie.addVectors(witteBal.position, camera.position);

				StokPositie = StokPositie.multiplyScalar(0.5);

				stokje.position.x = StokPositie.x;
				stokje.position.z = StokPositie.z;

				stokje.rotation.z = -camera.rotation.z;


                requestAnimationFrame(render);
                raycaster.setFromCamera(mouse, camera);
                renderer.render(scene, camera);


                for (var x=0; x < poolBallen.length; x++)
                {
                    for (var y=x+1; y < poolBallen.length; y++)
                    {
                        var distance_x = Math.abs(poolBallen[x].ball.position.x-poolBallen[y].ball.position.x);
                        var distance_y = Math.abs(poolBallen[x].ball.position.z-poolBallen[y].ball.position.z);
                        var distance = Math.sqrt(distance_x*distance_x+distance_y*distance_y);

                        if (distance <= 1 && (poolBallen[x].collision == 0 || poolBallen[y].collision == 0))
                        {
                            poolBallen[x].collision = 1;
                            poolBallen[y].collision = 1;
                            BounceMyBalls(poolBallen[x], poolBallen[y]);
                        }
                        else if (distance> 1)
                        {
                            poolBallen[x].collision = 0;
                            poolBallen[y].collision = 0;
                        }
                    }
                }




				//randen

				var warmteEnergieRendement = 0.95;

				for (var i = 0; i < poolBallen.length; i++ ) {
					if (poolBallen[i].ball.position.z < -19 || poolBallen[i].ball.position.z > 19)
					{
						if ((poolBallen[i].ball.position.x < -8 ||poolBallen[i].ball.position.x  > 8) &&  poolBallen[i].ball.position.y >= 0)
						{
							poolBallen[i].balDirection = new THREE.Vector3(0,0,0);
							poolBallen[i].fall = 1;
						}
						else {
						    if (poolBallen[i].randCollision == 0) {
                                poolBallen[i].randCollision = 1;
                                poolBallen[i].balDirection.z *= -1 * warmteEnergieRendement;
                            }
                            else if (poolBallen[i].ball.position.x >= -8 && poolBallen[i].ball.position.x <= 8 )
							{
                                poolBallen[i].randCollision = 0;
							}
						}
					}
					if (poolBallen[i].ball.position.x < -9 || poolBallen[i].ball.position.x > 9)
					{


						if ((poolBallen[i].ball.position.z < -18 || poolBallen[i].ball.position.z  > 18) && poolBallen[i].ball.position.y >= 0)
						{
							poolBallen[i].balDirection = new THREE.Vector3(0,0,0);
							poolBallen[i].fall = 1;
						}
						else{
                            if (poolBallen[i].randCollision == 0) {
                                poolBallen[i].randCollision = 1;
                                poolBallen[i].balDirection.x *= -1 * warmteEnergieRendement;
                            }
                            else if (poolBallen[i].ball.position.y >= -18 && poolBallen[i].ball.position.z <= 18 )
                            {
                                poolBallen[i].randCollision = 0;
                            }
						}
					}



					//vallen van middelste gaten
					if (poolBallen[i].ball.position.x < -7.85 || poolBallen[i].ball.position.x > 8.25) {

						if ((poolBallen[i].ball.position.z < 1.5 && poolBallen[i].ball.position.z > -1.5 ) && poolBallen[i].ball.position.y == 0) {
							poolBallen[i].ball.position.y -= .1;
							poolBallen[i].balDirection = new THREE.Vector3(0, 0, 0);
							poolBallen[i].fall = 1;
							console.log("fall");
							continue;
						}
					}



                    if (poolBallen[i].fall > 0){
						poolBallen[i].collision = 2;
                        poolBallen[i].ball.position.y -= .1;

                        if (poolBallen[i].ball.position.y <= -1)
                        {
							poolBallen[i].fall = 0;
                            poolBallen[i].ball.visible = false;
							if (i == 15){
								resetWitteBal();
							}

						}
					}


                }






			}
			
			
			// ########################################## mouse events #################################################



			document.addEventListener( 'keyup', function (event) {

				if(event.keyCode == 32 && controlsEnabled) {
					poolBallen[15].balDirection = new THREE.Vector3(.5, 0, -1);
				}

				else {
				    console.log("pointer lock");
					instructions.style.display = 'none';
					blocker.style.display = 'none';
					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
					element.requestPointerLock();
				}

			}, false );

			init();
		</script>
	</body>
</html>
