<!DOCTYPE html>
<html lang="en">
	<head>
		<title>ballen</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				width: 100%;
				height: 100%;
				margin: 0px;
			}
		</style>
	</head>
	<body>

		<script src="js/three.min.js"></script>
		
		<!--<script src="js/SpotLight.js"></script>
		<script src="js/FirstPersonControls.js"></script>-->

		<script>
		
			class PoolBal{
				constructor(baldirection, ball)
				{
					this.balDirection = baldirection;
					this.ball = ball;
					this.collision = 0;
				}				
			}
		
		
		;
            // ############################################## init #####################################################
			var scene = new THREE.Scene();

			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0x000000);
			document.body.appendChild(renderer.domElement);

            document.documentElement.style.overflow = 'hidden';  // firefox, chrome

            THREE.ImageUtils.crossOrigin = 'anonymous';
            texture = THREE.ImageUtils.loadTexture('img/front.jpg');
            texture.minFilter = THREE.LinearFilter;
            material = new THREE.MeshBasicMaterial({
			//map: texture
			color: 0xf0f0f0
			
			});


            //var groundTexture = new THREE.TextureLoader().load('img/front.jpg');


            //var floorMat = new THREE.MeshPhongMaterial( { map: groundTexture  } );

            var floor = new THREE.Mesh( new THREE.PlaneBufferGeometry(200,200,1,1), material);
            floor.position.y = -15;
            floor.rotation.x = - Math.PI / 2;
            scene.add(floor);

			var raycaster = new THREE.Raycaster();

			
			var poolBallen = [];
            var alleBallen = [];
		

			var speed = new THREE.Vector3();

			var clock = new THREE.Clock();

			var rotationPerFrame = 0.05;
			var rotationVector = new THREE.Vector3(rotationPerFrame,rotationPerFrame,rotationPerFrame);

			//scene.add(new THREE.AmbientLight(0xf0f0f0));
			scene.add( new THREE.AmbientLight(0x111111));

			var sphere = new THREE.SphereGeometry(0.5, 16, 8);

			var light1 = new THREE.PointLight(0xf0f0f0, 1.2, 100, 1);
			light1.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial( { color: 0xf0f0f0 } )));
			light1.position.set(0, 40, 0);
			scene.add(light1);


            // ############################################ pooltafel ##################################################
            var poolTafel = new THREE.Group();

            var tafelKleedMat = new THREE.MeshPhongMaterial({color: 0x228B22});

            var tafelKleed = new THREE.Mesh(new THREE.BoxGeometry(20, 40, 1), tafelKleedMat);
            tafelKleed.position.y = -1;
            tafelKleed.rotation.x = -Math.PI / 2;

            poolTafel.add(tafelKleed);

            var xRandGeo = new THREE.BoxGeometry(1, 1, 40);
            var zRandGeo = new THREE.BoxGeometry(21, 1, 1);
            var tafelPootGeo = new THREE.BoxGeometry(1, 40, 1);

            var randMat = new THREE.MeshPhongMaterial({color: 0x8B4513});
            var rand0 = new THREE.Mesh(xRandGeo, randMat);
            var rand1 = new THREE.Mesh(xRandGeo, randMat);
            var rand2 = new THREE.Mesh(zRandGeo, randMat);
            var rand3 = new THREE.Mesh(zRandGeo, randMat);

            var zranden = new THREE.Group();
            zranden.add(rand2);
            zranden.add(rand3);

            var xranden = new THREE.Group();
            xranden.add(rand0);
            xranden.add(rand1);

            poolTafel.add(zranden);
            poolTafel.add(xranden);

            rand0.position.set(-10, 0, 0);
            rand1.position.set(10, 0, 0);
            rand2.position.set(0, 0, -20);
            rand3.position.set(0, 0, 20);

            var tafelPoten = new THREE.Group();

            tafelPoot1 = new THREE.Mesh(tafelPootGeo, randMat);
            tafelPoot2 = new THREE.Mesh(tafelPootGeo, randMat);
            tafelPoot3 = new THREE.Mesh(tafelPootGeo, randMat);
            tafelPoot4 = new THREE.Mesh(tafelPootGeo, randMat);

            tafelPoten.add(tafelPoot1, tafelPoot2, tafelPoot3, tafelPoot4);

            tafelPoot1.position.set(-10, -20, 20);
            tafelPoot2.position.set(10, -20, 20);
            tafelPoot3.position.set(10, -20, -20);
            tafelPoot4.position.set(-10, -20, -20);

            poolTafel.add(tafelPoten);

            scene.add(poolTafel);


            // ############################################# balls #####################################################
            var ballen = new THREE.Group();
            var witteBal = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0xFFFFFF}));

            for (var i = 1; i < 16; i++) {
                if (i % 2 == 0) {
                    var Poolball = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0xff0040}));
                }
                else {
                    if (i == 11) {
                        var Poolball = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0x00000}));
                    }
                    else {
                        var Poolball = new THREE.Mesh(sphere, new THREE.MeshLambertMaterial({color: 0x0040ff}));
                    }
                }

                ballen.add(Poolball);
            }

			
			//ballen array
			for (var i = 0 ; i < ballen.children.length; i ++){

                ballen.children[i].name = "bal" + i;
			var bal = new PoolBal(new THREE.Vector3(0,0,0), ballen.children[i]);
				bal.name = "poolbal" + i;
				poolBallen.push(bal);
				alleBallen.push(ballen.children[i]);
			}

			witteBal.name = "bal" + 15;
            alleBallen.push(witteBal);




            var wittePoolBal = new PoolBal(new THREE.Vector3(0, 0, 0), witteBal);
            wittePoolBal.name = "poolbal" + 15;
			poolBallen.push(wittePoolBal);


			function returnBalDir(ball){
			
				for (var i = 0; i < poolBallen.length; i++){

					if (poolBallen[i].name == ball)
					{
						return poolBallen[i];
					}
				}
			}



            scene.add(ballen);
            scene.add(witteBal);
            witteBal.position.x = 0;
            witteBal.position.z = 10;


           // ballen.position.z = 1;
            //ballen.position.x = -5;


            for (var i = 0; i < ballen.children.length; i++) {
                ballen.children[i].position.z = -5;
                ballen.children[i].position.x = (i * 1.2) -2;
                if (i >= 5) {
                    ballen.children[i].position.x = ((i - 4.5) * 1.2) -2;
                    ballen.children[i].position.z = -4;
                }
                if (i >= 9) {
                    ballen.children[i].position.x = ((i - 8) * 1.2) -2;
                    ballen.children[i].position.z = -3;
                }
                if (i >= 12) {
                    ballen.children[i].position.x = ((i - 10.5) * 1.2) -2;
                    ballen.children[i].position.z = -2;
                }
                if (i >= 14) {
                    ballen.children[i].position.x = ((i - 12) * 1.2) -2;
                    ballen.children[i].position.z = -1;
                }
            }


            ballen.position.x = 0;
            ballen.position.z = 0;



			// ************************************* MANAGE BOUNCE ***************************************

			function BounceMyBalls(ball, ball2)
			{
			    var mass = 1;

				var dx = ball.ball.position.x - ball2.ball.position.x;
                var dy = ball.ball.position.z - ball2.ball.position.z;

                var collision_angle = Math.atan2(dy, dx);
                var magnitude_1 = Math.sqrt(ball.balDirection.x * ball.balDirection.x + ball.balDirection.z * ball.balDirection.z  )
                var magnitude_2 = Math.sqrt(ball2.balDirection.x * ball2.balDirection.x + ball2.balDirection.z * ball2.balDirection.z  )

				var direction_1 = Math.atan2( ball.balDirection.z, ball.balDirection.x);
                var direction_2 = Math.atan2( ball2.balDirection.z, ball2.balDirection.x);

				var new_xspeed_1 = magnitude_1 * Math.cos(direction_1 - collision_angle);
                var new_yspeed_1 = magnitude_1 * Math.sin(direction_1 - collision_angle);
                var new_xspeed_2 = magnitude_2 * Math.cos(direction_2 - collision_angle);
                var new_yspeed_2 = magnitude_2 * Math.sin(direction_2 - collision_angle);

                var final_xspeed_1 = ((mass-mass)*new_xspeed_1+(mass+mass)*new_xspeed_2)/(mass+mass);
                var final_xspeed_2 = ((mass+mass)*new_xspeed_1+(mass-mass)*new_xspeed_2)/(mass+mass);
                var final_yspeed_1 = new_yspeed_1;
                var final_yspeed_2 = new_yspeed_2;

                ball.balDirection.x = Math.cos(collision_angle)*final_xspeed_1+Math.cos(collision_angle+Math.PI/2)*final_yspeed_1;
                ball.balDirection.z = Math.sin(collision_angle)*final_xspeed_1+Math.sin(collision_angle+Math.PI/2)*final_yspeed_1;
                ball2.balDirection.x = Math.cos(collision_angle)*final_xspeed_2+Math.cos(collision_angle+Math.PI/2)*final_yspeed_2;
                ball2.balDirection.z = Math.sin(collision_angle)*final_xspeed_2+Math.sin(collision_angle+Math.PI/2)*final_yspeed_2;


			}



            // ############################################# render ###################################################
			function render() {

				var clockDelta = clock.getDelta() * 20;

                var drag = 0.996;

				poolBallen[15].balDirection.y = 0;
				witteBal.position.add(speed.copy(poolBallen[15].balDirection.multiplyScalar(drag)).multiplyScalar(clockDelta));
				//poolBallen[15].ball.position.add(poolBallen[15].balDirection);

                for (var i = 0; i < ballen.children.length; i++) {
                    poolBallen[i].balDirection.y = 0;
                    //poolBallen[i].ball.position.add(poolBallen[i].balDirection);
                    poolBallen[i].ball.position.add(speed.copy(poolBallen[i].balDirection.multiplyScalar(drag)).multiplyScalar(clockDelta));
                }


                renderer.setSize(window.innerWidth, window.innerHeight);


                camera.lookAt(witteBal.position);


                requestAnimationFrame(render);
                raycaster.setFromCamera(mouse, camera);
                renderer.render(scene, camera);






				//ball met bal
				/*
                for (var i = 0; i < poolBallen.length; i++ ) {
                    raycaster.set(poolBallen[i].ball.position, poolBallen[i].balDirection);
                    var intersections = raycaster.intersectObjects(alleBallen);
                    if (intersections.length > 0) {
                        var intersection = intersections[0];
                        if (intersection.distance <= .5) {
                            BounceMyBalls(poolBallen[i],  returnBalDir("pool" + intersection.object.name));
                        }
                    }

				*/



                for (var x=0; x < poolBallen.length; x++)
                {
                    for (var y=x+1; y < poolBallen.length; y++)
                    {
                        var distance_x = Math.abs(poolBallen[x].ball.position.x-poolBallen[y].ball.position.x);
                        var distance_y = Math.abs(poolBallen[x].ball.position.z-poolBallen[y].ball.position.z);
                        var distance = Math.sqrt(distance_x*distance_x+distance_y*distance_y);
					
                        if (distance <= 1 && (poolBallen[x].collision == 0 || poolBallen[y].collision == 0))
                        {
                            poolBallen[x].collision = 1;
                            poolBallen[y].collision = 1;
                            BounceMyBalls(poolBallen[x], poolBallen[y]);
                        }
                        else if (distance> 1)
                        {
                            poolBallen[x].collision = 0;
                            poolBallen[y].collision = 0;
                        }

                       //console.log(distance);

                        //indow.console.log(distance)
                    }
                }









				/*
                for (x=0; x<=ballen.length; x++)
                {
                    for (y=x+1; y<ballen.length; y++)
                    {
                        distance_x = Math.abs(ballen[x].position-ballen[y].position);
                        distance_y = Math.abs(ballen[x].position-ballsArray[y].position);
                        distance = Math.sqrt(distance_x*distance_x+distance_y*distance_y);

                        if (distance<=31 && (ballen[x].collision == 0 || ballen[y].collision == 0))
                        {
                            ballsArray[x].collision = 1;
                            ballsArray[y].collision = 1;
                            manage_bounce(ballsArray[x], ballsArray[y]);
                        }
                        else if (distance>31)
                        {
                            ballsArray[x].collision = 0;
                            ballsArray[y].collision = 0;
                        }

                        //window.console.log(distance)
                    }

                }

                      */


				//randen


				for (var i = 0; i < poolBallen.length; i++ ) {
                    raycaster.set(poolBallen[i].ball.position, poolBallen[i].balDirection);

                    var intersections = raycaster.intersectObjects(zranden.children);

                    if (intersections.length > 0) {
                        var intersection = intersections[0];

                        if (intersection.distance <= .5) {
                            poolBallen[i].balDirection.z *= -1;
                        }
                    }

                    var intersections = raycaster.intersectObjects(xranden.children);

                    if (intersections.length > 0) {
                        var intersection = intersections[0];

                        if (intersection.distance <= .5) {
                            poolBallen[i].balDirection.x *= -1;
                        }
                    }

                }






			}
			
			
			// ########################################## mouse events #################################################
			var mouse = new THREE.Vector2();

			document.addEventListener('click', function(){
			
			
			    poolBallen[15].balDirection = new THREE.Vector3(camera.rotation.z,0,camera.rotation.x);
				
				
            });

			document.addEventListener('contextmenu', function(e1){
				var mx = e1.pageX;
				e1.preventDefault();
				document.addEventListener('mousemove', function(e2){
					if(mx < e2.pageX){
						//console.log("left");
					}
					else{
						//console.log("right");
					}
				})
			});

            camera.position.set(x = 0,y = 10,z = 25);

			document.addEventListener('mousewheel', function(event) {
                if (event.wheelDelta < 0 ) {
                    if (camera.position.y < 30) camera.position.y++;
					                }
                else {
                    if(camera.position.y > -15) camera.position.y--;
                }
            });


            render();
		</script>
	</body>
</html>
